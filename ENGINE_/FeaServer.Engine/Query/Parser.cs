//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.261
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace FeaServer.Engine.Query {
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    
    // The following table contains information about every rule that is used during the reduce.
    public class Parser : System.IDisposable {
        protected const int NOCODE = 221;
        protected const int WILDCARD = 70;
        protected const int STATES = 0;
        protected const int ERRORSYMBOL = 0;
        private string _tracePrompt;
        #region Trace: Token Names
        protected static string[] _tokenNames = new string[] {
                "$",
                "SEMI",
                "EXPLAIN",
                "QUERY",
                "PLAN",
                "BEGIN",
                "TRANSACTION",
                "DEFERRED",
                "IMMEDIATE",
                "EXCLUSIVE",
                "COMMIT",
                "END",
                "ROLLBACK",
                "SAVEPOINT",
                "RELEASE",
                "TO",
                "TABLE",
                "CREATE",
                "IF",
                "NOT",
                "EXISTS",
                "TEMP",
                "LP",
                "RP",
                "AS",
                "COMMA",
                "ID",
                "INDEXED",
                "ABORT",
                "ACTION",
                "AFTER",
                "ANALYZE",
                "ASC",
                "ATTACH",
                "BEFORE",
                "BY",
                "CASCADE",
                "CAST",
                "COLUMNKW",
                "CONFLICT",
                "DATABASE",
                "DESC",
                "DETACH",
                "EACH",
                "FAIL",
                "FOR",
                "IGNORE",
                "INITIALLY",
                "INSTEAD",
                "LIKE_KW",
                "MATCH",
                "NO",
                "KEY",
                "OF",
                "OFFSET",
                "PRAGMA",
                "RAISE",
                "REPLACE",
                "RESTRICT",
                "ROW",
                "TRIGGER",
                "VACUUM",
                "VIEW",
                "VIRTUAL",
                "EXCEPT",
                "INTERSECT",
                "UNION",
                "REINDEX",
                "RENAME",
                "CTIME_KW",
                "ANY",
                "OR",
                "AND",
                "IS",
                "BETWEEN",
                "IN",
                "ISNULL",
                "NOTNULL",
                "NE",
                "EQ",
                "GT",
                "LE",
                "LT",
                "GE",
                "ESCAPE",
                "BITAND",
                "BITOR",
                "LSHIFT",
                "RSHIFT",
                "PLUS",
                "MINUS",
                "STAR",
                "SLASH",
                "REM",
                "CONCAT",
                "COLLATE",
                "BITNOT",
                "STRING",
                "JOIN_KW",
                "CONSTRAINT",
                "DEFAULT",
                "NULL",
                "PRIMARY",
                "UNIQUE",
                "CHECK",
                "REFERENCES",
                "AUTOINCR",
                "ON",
                "INSERT",
                "DELETE",
                "UPDATE",
                "SET",
                "DEFERRABLE",
                "FOREIGN",
                "DROP",
                "ALL",
                "SELECT",
                "DISTINCT",
                "DOT",
                "FROM",
                "JOIN",
                "USING",
                "ORDER",
                "GROUP",
                "HAVING",
                "LIMIT",
                "WHERE",
                "INTO",
                "VALUES",
                "INTEGER",
                "FLOAT",
                "BLOB",
                "REGISTER",
                "VARIABLE",
                "error",
                "input",
                "cmdlist",
                "ecmd",
                "explain",
                "cmdx",
                "cmd",
                "transtype",
                "trans_opt",
                "nm",
                "savepoint_opt",
                "create_table",
                "create_table_args",
                "createkw",
                "temp",
                "ifnotexists",
                "dbnm",
                "columnlist",
                "conslist_opt",
                "select",
                "column",
                "columnid",
                "type",
                "carglist",
                "id",
                "ids",
                "typetoken",
                "typename",
                "signed",
                "plus_num",
                "minus_num",
                "carg",
                "ccons",
                "term",
                "expr",
                "onconf",
                "sortorder",
                "autoinc",
                "idxlist_opt",
                "refargs",
                "defer_subclause",
                "refarg",
                "refact",
                "init_deferred_pred_opt",
                "conslist",
                "tcons",
                "idxlist",
                "defer_subclause_opt",
                "orconf",
                "resolvetype",
                "raisetype",
                "ifexists",
                "fullname",
                "sqlite3Select",
                "db",
                "oneselect",
                "multiselect_op",
                "selcollist",
                "from",
                "where_opt",
                "groupby_opt",
                "having_opt",
                "orderby_opt",
                "limit_opt",
                "distinct",
                "sclp",
                "as",
                "seltablist",
                "stl_prefix",
                "joinop",
                "indexed_opt",
                "on_opt",
                "using_opt",
                "joinop2",
                "inscollist",
                "sortlist",
                "sortitem",
                "nexprlist",
                "setlist",
                "insert_cmd",
                "inscollist_opt",
                "itemlist",
                "exprlist",
                "likeop",
                "between_op",
                "in_op"};
        #endregion
        #region Trace: Rule Names
        protected static string[] _ruleNames = new string[] {
                "input ::= cmdlist",
                "cmdlist ::= cmdlist ecmd",
                "cmdlist ::= ecmd",
                "ecmd ::= SEMI",
                "ecmd ::= explain cmdx SEMI",
                "explain ::=",
                "explain ::= EXPLAIN",
                "explain ::= EXPLAIN QUERY PLAN",
                "cmdx ::= cmd",
                "cmd ::= BEGIN transtype trans_opt",
                "trans_opt ::=",
                "trans_opt ::= TRANSACTION",
                "trans_opt ::= TRANSACTION nm",
                "transtype ::=",
                "transtype ::= DEFERRED",
                "transtype ::= IMMEDIATE",
                "transtype ::= EXCLUSIVE",
                "cmd ::= COMMIT trans_opt",
                "cmd ::= END trans_opt",
                "cmd ::= ROLLBACK trans_opt",
                "savepoint_opt ::= SAVEPOINT",
                "savepoint_opt ::=",
                "cmd ::= SAVEPOINT nm",
                "cmd ::= RELEASE savepoint_opt nm",
                "cmd ::= ROLLBACK trans_opt TO savepoint_opt nm",
                "cmd ::= create_table create_table_args",
                "create_table ::= createkw temp TABLE ifnotexists nm dbnm",
                "createkw ::= CREATE",
                "ifnotexists ::=",
                "ifnotexists ::= IF NOT EXISTS",
                "temp ::= TEMP",
                "temp ::=",
                "create_table_args ::= LP columnlist conslist_opt RP",
                "create_table_args ::= AS select",
                "columnlist ::= columnlist COMMA column",
                "columnlist ::= column",
                "column ::= columnid type carglist",
                "columnid ::= nm",
                "id ::= ID",
                "id ::= INDEXED",
                "ids ::= ID|STRING",
                "nm ::= id",
                "nm ::= STRING",
                "nm ::= JOIN_KW",
                "type ::=",
                "type ::= typetoken",
                "typetoken ::= typename",
                "typetoken ::= typename LP signed RP",
                "typetoken ::= typename LP signed COMMA signed RP",
                "typename ::= ids",
                "typename ::= typename ids",
                "signed ::= plus_num",
                "signed ::= minus_num",
                "carglist ::= carglist carg",
                "carglist ::=",
                "carg ::= CONSTRAINT nm ccons",
                "carg ::= ccons",
                "ccons ::= DEFAULT term",
                "ccons ::= DEFAULT LP expr RP",
                "ccons ::= DEFAULT PLUS term",
                "ccons ::= DEFAULT MINUS term",
                "ccons ::= DEFAULT id",
                "ccons ::= NULL onconf",
                "ccons ::= NOT NULL onconf",
                "ccons ::= PRIMARY KEY sortorder onconf autoinc",
                "ccons ::= UNIQUE onconf",
                "ccons ::= CHECK LP expr RP",
                "ccons ::= REFERENCES nm idxlist_opt refargs",
                "ccons ::= defer_subclause",
                "ccons ::= COLLATE ids",
                "autoinc ::=",
                "autoinc ::= AUTOINCR",
                "refargs ::=",
                "refargs ::= refargs refarg",
                "refarg ::= MATCH nm",
                "refarg ::= ON INSERT refact",
                "refarg ::= ON DELETE refact",
                "refarg ::= ON UPDATE refact",
                "refact ::= SET NULL",
                "refact ::= SET DEFAULT",
                "refact ::= CASCADE",
                "refact ::= RESTRICT",
                "refact ::= NO ACTION",
                "defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt",
                "defer_subclause ::= DEFERRABLE init_deferred_pred_opt",
                "init_deferred_pred_opt ::=",
                "init_deferred_pred_opt ::= INITIALLY DEFERRED",
                "init_deferred_pred_opt ::= INITIALLY IMMEDIATE",
                "conslist_opt ::=",
                "conslist_opt ::= COMMA conslist",
                "conslist ::= conslist COMMA tcons",
                "conslist ::= conslist tcons",
                "conslist ::= tcons",
                "tcons ::= CONSTRAINT nm",
                "tcons ::= PRIMARY KEY LP idxlist autoinc RP onconf",
                "tcons ::= UNIQUE LP idxlist RP onconf",
                "tcons ::= CHECK LP expr RP onconf",
                "tcons ::= FOREIGN KEY LP idxlist RP REFERENCES nm idxlist_opt refargs defer_subcl" +
                    "ause_opt",
                "defer_subclause_opt ::=",
                "defer_subclause_opt ::= defer_subclause",
                "onconf ::=",
                "onconf ::= ON CONFLICT resolvetype",
                "orconf ::=",
                "orconf ::= OR resolvetype",
                "resolvetype ::= raisetype",
                "resolvetype ::= IGNORE",
                "resolvetype ::= REPLACE",
                "cmd ::= DROP TABLE ifexists fullname",
                "ifexists ::= IF EXISTS",
                "ifexists ::=",
                "cmd ::= select",
                "select ::= oneselect",
                "select ::= select multiselect_op oneselect",
                "multiselect_op ::= UNION",
                "multiselect_op ::= UNION ALL",
                "multiselect_op ::= EXCEPT|INTERSECT",
                "oneselect ::= SELECT selcollist from where_opt groupby_opt having_opt orderby_opt" +
                    " limit_opt",
                "distinct ::= DISTINCT",
                "distinct ::= ALL",
                "distinct ::=",
                "sclp ::= selcollist COMMA",
                "sclp ::=",
                "selcollist ::= sclp expr as",
                "selcollist ::= sclp STAR",
                "selcollist ::= sclp nm DOT STAR",
                "as ::= AS nm",
                "as ::= ids",
                "as ::=",
                "from ::=",
                "from ::= FROM seltablist",
                "stl_prefix ::= seltablist joinop",
                "stl_prefix ::=",
                "seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt",
                "seltablist ::= stl_prefix LP select RP as on_opt using_opt",
                "seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt",
                "dbnm ::=",
                "dbnm ::= DOT nm",
                "fullname ::= nm dbnm",
                "joinop ::= COMMA|JOIN",
                "joinop ::= JOIN_KW JOIN",
                "joinop ::= JOIN_KW nm JOIN",
                "joinop ::= JOIN_KW nm nm JOIN",
                "on_opt ::= ON expr",
                "on_opt ::=",
                "indexed_opt ::=",
                "indexed_opt ::= INDEXED BY nm",
                "indexed_opt ::= NOT INDEXED",
                "using_opt ::= USING LP inscollist RP",
                "using_opt ::=",
                "orderby_opt ::=",
                "orderby_opt ::= ORDER BY sortlist",
                "sortlist ::= sortlist COMMA sortitem sortorder",
                "sortlist ::= sortitem sortorder",
                "sortitem ::= expr",
                "sortorder ::= ASC",
                "sortorder ::= DESC",
                "sortorder ::=",
                "groupby_opt ::=",
                "groupby_opt ::= GROUP BY nexprlist",
                "having_opt ::=",
                "having_opt ::= HAVING expr",
                "limit_opt ::=",
                "limit_opt ::= LIMIT expr",
                "limit_opt ::= LIMIT expr OFFSET expr",
                "limit_opt ::= LIMIT expr COMMA expr",
                "cmd ::= DELETE FROM fullname indexed_opt where_opt",
                "where_opt ::=",
                "where_opt ::= WHERE expr",
                "cmd ::= UPDATE orconf fullname indexed_opt SET setlist where_opt",
                "setlist ::= setlist COMMA nm EQ expr",
                "setlist ::= nm EQ expr",
                "cmd ::= insert_cmd INTO fullname inscollist_opt VALUES LP itemlist RP",
                "cmd ::= insert_cmd INTO fullname inscollist_opt select",
                "cmd ::= insert_cmd INTO fullname inscollist_opt DEFAULT VALUES",
                "insert_cmd ::= INSERT orconf",
                "insert_cmd ::= REPLACE",
                "itemlist ::= itemlist COMMA expr",
                "itemlist ::= expr",
                "inscollist_opt ::=",
                "inscollist_opt ::= LP inscollist RP",
                "inscollist ::= inscollist COMMA nm",
                "inscollist ::= nm",
                "expr ::= term",
                "expr ::= LP expr RP",
                "term ::= NULL",
                "expr ::= id",
                "expr ::= JOIN_KW",
                "expr ::= nm DOT nm",
                "expr ::= nm DOT nm DOT nm",
                "term ::= INTEGER|FLOAT|BLOB",
                "term ::= STRING",
                "expr ::= REGISTER",
                "expr ::= VARIABLE",
                "expr ::= expr COLLATE ids",
                "expr ::= CAST LP expr AS typetoken RP",
                "expr ::= ID LP distinct exprlist RP",
                "expr ::= ID LP STAR RP",
                "term ::= CTIME_KW",
                "expr ::= expr AND expr",
                "expr ::= expr OR expr",
                "expr ::= expr LT|GT|GE|LE expr",
                "expr ::= expr EQ|NE expr",
                "expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr",
                "expr ::= expr PLUS|MINUS expr",
                "expr ::= expr STAR|SLASH|REM expr",
                "expr ::= expr CONCAT expr",
                "likeop ::= LIKE_KW",
                "likeop ::= NOT LIKE_KW",
                "likeop ::= MATCH",
                "likeop ::= NOT MATCH",
                "expr ::= expr likeop expr",
                "expr ::= expr likeop expr ESCAPE expr",
                "expr ::= expr ISNULL|NOTNULL",
                "expr ::= expr NOT NULL",
                "expr ::= expr IS expr",
                "expr ::= expr IS NOT expr",
                "expr ::= NOT expr",
                "expr ::= BITNOT expr",
                "expr ::= MINUS expr",
                "expr ::= PLUS expr",
                "between_op ::= BETWEEN",
                "between_op ::= NOT BETWEEN",
                "expr ::= expr between_op expr AND expr",
                "in_op ::= IN",
                "in_op ::= NOT IN",
                "expr ::= expr in_op LP exprlist RP",
                "expr ::= LP select RP",
                "expr ::= expr in_op LP select RP"};
        #endregion
        protected static Minor _zeroMinor;
        protected const int ACTIONS = 0;
        #region Tables: Actions
        protected static byte[] _actions = new byte[0];
        #endregion
        protected const int NO_ACTION = 230;
        protected const int ACCEPT_ACTION = 229;
        protected const int ERROR_ACTION = 228;
        #region Tables: Lookaheads
        protected static byte[] _lookaheads = new byte[0];
        #endregion
        protected const int SHIFT_USE_DFLT = -1;
        protected const int SHIFT_COUNT = -1;
        protected const int SHIFT_MIN = 0;
        protected const int SHIFT_MAX = 0;
        #region Tables: Shift Offsets
        protected static sbyte[] _shift_ofsts = new sbyte[0];
        #endregion
        protected const int REDUCE_USE_DFLT = -1;
        protected const int REDUCE_COUNT = -1;
        protected const int REDUCE_MIN = 0;
        protected const int REDUCE_MAX = 0;
        #region Tables: Reduce Offsets
        protected static sbyte[] _reduce_ofsts = new sbyte[0];
        #endregion
        #region Tables: Defaults
        protected static byte[] _defaults = new byte[0];
        #endregion
        #region Tables: Fallbacks
        protected static byte[] _fallbacks = new byte[] {
                default(byte),
                default(byte),
                26,
                26,
                26,
                26,
                default(byte),
                26,
                26,
                26,
                default(byte),
                26,
                26,
                26,
                26,
                default(byte),
                default(byte),
                default(byte),
                26,
                default(byte),
                default(byte),
                26,
                default(byte),
                default(byte),
                default(byte),
                default(byte),
                default(byte),
                default(byte),
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26,
                26};
        #endregion
        // Index of top element in stack
        protected int _idx = -1;
        // Shifts left before out of the error
        protected int _errors;
        // A place to hold %extra_argument
        private Parse _pParse;
        // The parser's stack
        protected StackEntry[] _stack = new StackEntry[100];
        #region Tables: Rule Infos
        protected static RuleInfo[] _ruleInfos = new RuleInfo[] {
                new RuleInfo(135, 1),
                new RuleInfo(136, 2),
                new RuleInfo(136, 1),
                new RuleInfo(137, 1),
                new RuleInfo(137, 3),
                new RuleInfo(138, 0),
                new RuleInfo(138, 1),
                new RuleInfo(138, 3),
                new RuleInfo(139, 1),
                new RuleInfo(140, 3),
                new RuleInfo(142, 0),
                new RuleInfo(142, 1),
                new RuleInfo(142, 2),
                new RuleInfo(141, 0),
                new RuleInfo(141, 1),
                new RuleInfo(141, 1),
                new RuleInfo(141, 1),
                new RuleInfo(140, 2),
                new RuleInfo(140, 2),
                new RuleInfo(140, 2),
                new RuleInfo(144, 1),
                new RuleInfo(144, 0),
                new RuleInfo(140, 2),
                new RuleInfo(140, 3),
                new RuleInfo(140, 5),
                new RuleInfo(140, 2),
                new RuleInfo(145, 6),
                new RuleInfo(147, 1),
                new RuleInfo(149, 0),
                new RuleInfo(149, 3),
                new RuleInfo(148, 1),
                new RuleInfo(148, 0),
                new RuleInfo(146, 4),
                new RuleInfo(146, 2),
                new RuleInfo(151, 3),
                new RuleInfo(151, 1),
                new RuleInfo(154, 3),
                new RuleInfo(155, 1),
                new RuleInfo(158, 1),
                new RuleInfo(158, 1),
                new RuleInfo(159, 1),
                new RuleInfo(143, 1),
                new RuleInfo(143, 1),
                new RuleInfo(143, 1),
                new RuleInfo(156, 0),
                new RuleInfo(156, 1),
                new RuleInfo(160, 1),
                new RuleInfo(160, 4),
                new RuleInfo(160, 6),
                new RuleInfo(161, 1),
                new RuleInfo(161, 2),
                new RuleInfo(162, 1),
                new RuleInfo(162, 1),
                new RuleInfo(157, 2),
                new RuleInfo(157, 0),
                new RuleInfo(165, 3),
                new RuleInfo(165, 1),
                new RuleInfo(166, 2),
                new RuleInfo(166, 4),
                new RuleInfo(166, 3),
                new RuleInfo(166, 3),
                new RuleInfo(166, 2),
                new RuleInfo(166, 2),
                new RuleInfo(166, 3),
                new RuleInfo(166, 5),
                new RuleInfo(166, 2),
                new RuleInfo(166, 4),
                new RuleInfo(166, 4),
                new RuleInfo(166, 1),
                new RuleInfo(166, 2),
                new RuleInfo(171, 0),
                new RuleInfo(171, 1),
                new RuleInfo(173, 0),
                new RuleInfo(173, 2),
                new RuleInfo(175, 2),
                new RuleInfo(175, 3),
                new RuleInfo(175, 3),
                new RuleInfo(175, 3),
                new RuleInfo(176, 2),
                new RuleInfo(176, 2),
                new RuleInfo(176, 1),
                new RuleInfo(176, 1),
                new RuleInfo(176, 2),
                new RuleInfo(174, 3),
                new RuleInfo(174, 2),
                new RuleInfo(177, 0),
                new RuleInfo(177, 2),
                new RuleInfo(177, 2),
                new RuleInfo(152, 0),
                new RuleInfo(152, 2),
                new RuleInfo(178, 3),
                new RuleInfo(178, 2),
                new RuleInfo(178, 1),
                new RuleInfo(179, 2),
                new RuleInfo(179, 7),
                new RuleInfo(179, 5),
                new RuleInfo(179, 5),
                new RuleInfo(179, 10),
                new RuleInfo(181, 0),
                new RuleInfo(181, 1),
                new RuleInfo(169, 0),
                new RuleInfo(169, 3),
                new RuleInfo(182, 0),
                new RuleInfo(182, 2),
                new RuleInfo(183, 1),
                new RuleInfo(183, 1),
                new RuleInfo(183, 1),
                new RuleInfo(140, 4),
                new RuleInfo(185, 2),
                new RuleInfo(185, 0),
                new RuleInfo(140, 1),
                new RuleInfo(153, 1),
                new RuleInfo(153, 3),
                new RuleInfo(190, 1),
                new RuleInfo(190, 2),
                new RuleInfo(190, 1),
                new RuleInfo(189, 8),
                new RuleInfo(198, 1),
                new RuleInfo(198, 1),
                new RuleInfo(198, 0),
                new RuleInfo(199, 2),
                new RuleInfo(199, 0),
                new RuleInfo(191, 3),
                new RuleInfo(191, 2),
                new RuleInfo(191, 4),
                new RuleInfo(200, 2),
                new RuleInfo(200, 1),
                new RuleInfo(200, 0),
                new RuleInfo(192, 0),
                new RuleInfo(192, 2),
                new RuleInfo(202, 2),
                new RuleInfo(202, 0),
                new RuleInfo(201, 7),
                new RuleInfo(201, 7),
                new RuleInfo(201, 7),
                new RuleInfo(150, 0),
                new RuleInfo(150, 2),
                new RuleInfo(186, 2),
                new RuleInfo(203, 1),
                new RuleInfo(203, 2),
                new RuleInfo(203, 3),
                new RuleInfo(203, 4),
                new RuleInfo(205, 2),
                new RuleInfo(205, 0),
                new RuleInfo(204, 0),
                new RuleInfo(204, 3),
                new RuleInfo(204, 2),
                new RuleInfo(206, 4),
                new RuleInfo(206, 0),
                new RuleInfo(196, 0),
                new RuleInfo(196, 3),
                new RuleInfo(209, 4),
                new RuleInfo(209, 2),
                new RuleInfo(210, 1),
                new RuleInfo(170, 1),
                new RuleInfo(170, 1),
                new RuleInfo(170, 0),
                new RuleInfo(194, 0),
                new RuleInfo(194, 3),
                new RuleInfo(195, 0),
                new RuleInfo(195, 2),
                new RuleInfo(197, 0),
                new RuleInfo(197, 2),
                new RuleInfo(197, 4),
                new RuleInfo(197, 4),
                new RuleInfo(140, 5),
                new RuleInfo(193, 0),
                new RuleInfo(193, 2),
                new RuleInfo(140, 7),
                new RuleInfo(212, 5),
                new RuleInfo(212, 3),
                new RuleInfo(140, 8),
                new RuleInfo(140, 5),
                new RuleInfo(140, 6),
                new RuleInfo(213, 2),
                new RuleInfo(213, 1),
                new RuleInfo(215, 3),
                new RuleInfo(215, 1),
                new RuleInfo(214, 0),
                new RuleInfo(214, 3),
                new RuleInfo(208, 3),
                new RuleInfo(208, 1),
                new RuleInfo(168, 1),
                new RuleInfo(168, 3),
                new RuleInfo(167, 1),
                new RuleInfo(168, 1),
                new RuleInfo(168, 1),
                new RuleInfo(168, 3),
                new RuleInfo(168, 5),
                new RuleInfo(167, 1),
                new RuleInfo(167, 1),
                new RuleInfo(168, 1),
                new RuleInfo(168, 1),
                new RuleInfo(168, 3),
                new RuleInfo(168, 6),
                new RuleInfo(168, 5),
                new RuleInfo(168, 4),
                new RuleInfo(167, 1),
                new RuleInfo(168, 3),
                new RuleInfo(168, 3),
                new RuleInfo(168, 3),
                new RuleInfo(168, 3),
                new RuleInfo(168, 3),
                new RuleInfo(168, 3),
                new RuleInfo(168, 3),
                new RuleInfo(168, 3),
                new RuleInfo(217, 1),
                new RuleInfo(217, 2),
                new RuleInfo(217, 1),
                new RuleInfo(217, 2),
                new RuleInfo(168, 3),
                new RuleInfo(168, 5),
                new RuleInfo(168, 2),
                new RuleInfo(168, 3),
                new RuleInfo(168, 3),
                new RuleInfo(168, 4),
                new RuleInfo(168, 2),
                new RuleInfo(168, 2),
                new RuleInfo(168, 2),
                new RuleInfo(168, 2),
                new RuleInfo(218, 1),
                new RuleInfo(218, 2),
                new RuleInfo(168, 5),
                new RuleInfo(219, 1),
                new RuleInfo(219, 2),
                new RuleInfo(168, 5),
                new RuleInfo(168, 3),
                new RuleInfo(168, 5)};
        #endregion
        #region TracePrompt
        /// <summary>
        /// Turn parser tracing on by giving a stream to which to write the trace and a prompt to preface each trace message.
        /// </summary>
        public virtual string TracePrompt {
            get {
                return this._tracePrompt;
            }
            set {
                this._tracePrompt = value;
            }
        }
        #endregion
        #region Dispose
        /// <summary>
        /// Deallocate and destroy a parser.  Destructors are all called for all stack elements before shutting the parser down.
        /// </summary>
        public virtual void Dispose() {
            for (
            ; (this._idx >= 0); 
            ) {
                this.PopParserStack();
            }
        }
        #endregion
        #region PopParserStack
        /// <summary>
        /// Pop the parser's stack once.
        /// If there is a destructor routine associated with the token which is popped from the stack, then call it.
        /// </summary>
        /// <returns>Return the major token number for the symbol popped.</returns>
        protected virtual int PopParserStack() {
            StackEntry tos = this._stack[this._idx];
            if ((this._idx < 0)) {
                return 0;
            }
            if (((this._tracePrompt != null) 
                        && (this._idx >= 0))) {
                Trace.WriteLine(String.Format("{0}Popping {1}", this._tracePrompt, _tokenNames[tos.major]));
            }
            byte major = tos.major;
            this.Destructor(major, tos.minor);
            this._idx = (this._idx - 1);
            return major;
        }
        #endregion
        #region FindShiftAction
        /// <summary>
        /// Find the appropriate action for a parser given the terminal look-ahead token lookahead.
        /// If the look-ahead token is NOCODE, then check to see if the action is independent of the look-ahead.  If it is, return the action, otherwise return NO_ACTION.
        /// </summary>
        /// <param name="lookahead"></param>
        /// <returns></returns>
        protected virtual int FindShiftAction(byte lookahead) {
            int i;
            int stateno = this._stack[this._idx].stateno;
            if (((stateno > SHIFT_COUNT) 
                        || ((i = _shift_ofsts[stateno]) == SHIFT_USE_DFLT))) {
                return _defaults[stateno];
            }
            Debug.Assert((lookahead != NOCODE));
            i = (i + lookahead);
            if (((i < 0) 
                        || ((i >= ACTIONS) 
                        || (_lookaheads[i] != lookahead)))) {
                if ((lookahead > 0)) {
                    byte fallback;
                    if (((lookahead < _fallbacks.Length) 
                                && ((fallback = _fallbacks[lookahead]) == 0))) {
                        if ((this._tracePrompt != null)) {
                            Trace.WriteLine(String.Format("{0}FALLBACK {1} => {2}", this._tracePrompt, _tokenNames[lookahead], _tokenNames[fallback]));
                        }
                        return this.FindShiftAction(fallback);
                    }
                    int j = (i 
                                + (lookahead + WILDCARD));
                    if (((_lookaheads[j] == WILDCARD) 
                                && (j < ACTIONS))) {
                        if ((this._tracePrompt != null)) {
                            Trace.WriteLine(String.Format("{0}WILDCARD {1} => {2}", this._tracePrompt, _tokenNames[lookahead], _tokenNames[WILDCARD]));
                        }
                        return _actions[j];
                    }
                }
                return _defaults[stateno];
            }
            else {
                return _actions[i];
            }
        }
        #endregion
        #region FindReduceAction
        // <summary>
        // Find the appropriate action for a parser given the non-terminal look-ahead token lookahead.
        // If the look-ahead token is NOCODE, then check to see if the action is independent of the look-ahead.  If it is, return the action, otherwise return NO_ACTION.
        // </summary>
        protected virtual int FindReduceAction(int stateno, byte lookahead) {
            Debug.Assert((stateno <= REDUCE_COUNT));
            int i = _reduce_ofsts[stateno];
            Debug.Assert((i != REDUCE_USE_DFLT));
            Debug.Assert((lookahead != NOCODE));
            i = (i + lookahead);
            Debug.Assert(((i >= 0) 
                            && (i < ACTIONS)));
            Debug.Assert((_lookaheads[i] == lookahead));
            return _actions[i];
        }
        #endregion
        #region Shift
        // <summary>
        // Perform a shift action.
        // </summary>
        protected virtual void Shift(int newState, int major, Minor minor) {
            this._idx = (this._idx + 1);
            if ((this._idx >= 100)) {
                this.StackOverflow(minor);
                return;
            }
            StackEntry tos = this._stack[this._idx];
            tos.stateno = ((byte)(newState));
            tos.major = ((byte)(major));
            tos.minor = minor;
            this._stack[this._idx] = tos;
            if (((this._tracePrompt != null) 
                        && (this._idx > 0))) {
                Trace.WriteLine(String.Format("{0}Shift {1}", this._tracePrompt, newState));
                System.Text.StringBuilder b = new System.Text.StringBuilder(String.Format("{0}Stack:", this._tracePrompt));
                for (int i = 1; (i <= this._idx); i = (i + 1)) {
                    b.AppendFormat(_tokenNames[this._stack[i].major]);
                }
                b.ToString();
                Trace.WriteLine(b.ToString());
            }
        }
        #endregion
        #region Parse
        // <summary>
        // The main parser.
        // </summary>
        public virtual void Parse(int major, Token minor, Parse pParse) {
            if ((this._idx < 0)) {
                this._idx = 0;
                this._errors = -1;
                this._stack[0].stateno = 0;
                this._stack[0].major = 0;
            }
            Minor minorUnion = _zeroMinor;
            minorUnion.yy0 = minor;
            bool endOfInput = (major == 0);
            this._pParse = pParse;
            if ((this._tracePrompt != null)) {
                Trace.WriteLine(String.Format("{0}Input {1}", this._tracePrompt, _tokenNames[major]));
            }
            for (bool do1 = true; do1; do1 = ((major != NOCODE) 
                        && (this._idx >= 0))) {
                int action = this.FindShiftAction(((byte)(major)));
                if ((action < STATES)) {
                    Debug.Assert((endOfInput == false));
                    this.Shift(action, major, minorUnion);
                    this._errors = (this._errors + 1);
                    major = NOCODE;
                }
                else {
                    if ((action < 228)) {
                        this.Reduce((action - STATES));
                    }
                    else {
                        Debug.Assert((action == ERROR_ACTION));
                        if ((this._tracePrompt != null)) {
                            Trace.WriteLine(String.Format("{0}Syntax Error!", this._tracePrompt));
                        }
                        if ((this._errors <= 0)) {
                            this.SyntaxError(major, minorUnion);
                        }
                        this._errors = 3;
                        this.Destructor(((byte)(major)), minorUnion);
                        if ((endOfInput == true)) {
                            this.ParseFailed();
                        }
                        major = NOCODE;
                    }
                }
            }
        }
        #endregion
        #region Destructors (switch)
        /// <summary>
        /// The following function deletes the value associated with a symbol.  The symbol can be either a terminal or nonterminal.
        /// "major" is the symbol code, and "minor" is a pointer to the value.
        /// </summary>
        private void Destructor(byte major, Minor minor) {
            Parse pParse = this._pParse;
switch (major) {
            // Here is inserted the actions which take place when a terminal or non-terminal is destroyed.  This can happen when the symbol is popped
            // from the stack during a reduce or during error processing or when a parser is being destroyed before it is finished parsing.
            // Note: during a reduce, the only symbols destroyed are those which appear on the RHS of the rule, but which are not used inside the C code.
    case 153: /* select */
    case 189: /* oneselect */
{
 sqlite3SelectDelete(pParse.db, (minor.yy0)); 
}
      break;
    case 167: /* term */
    case 168: /* expr */
{
 sqlite3ExprDelete(pParse.db, (minor.yy0).pExpr); 
}
      break;
    case 186: /* fullname */
    case 192: /* from */
    case 201: /* seltablist */
    case 202: /* stl_prefix */
{
 sqlite3SrcListDelete(pParse.db, (minor.yy0)); 
}
      break;
    case 191: /* selcollist */
    case 194: /* groupby_opt */
    case 196: /* orderby_opt */
    case 199: /* sclp */
    case 209: /* sortlist */
    case 212: /* setlist */
    case 215: /* itemlist */
{
 sqlite3ExprListDelete(pParse.db, (minor.yy0)); 
}
      break;
    case 193: /* where_opt */
    case 195: /* having_opt */
    case 205: /* on_opt */
    case 210: /* sortitem */
{
 sqlite3ExprDelete(pParse.db, (minor.yy0)); 
}
      break;
    case 206: /* using_opt */
    case 208: /* inscollist */
    case 214: /* inscollist_opt */
{
 sqlite3IdListDelete(pParse.db, (minor.yy0)); 
}
      break;
}
        }
        #endregion
        #region Reduce (switch)
        /// <summary>
        /// Perform a reduce action and the shift that must immediately follow the reduce.
        /// </summary>
        private void Reduce(int ruleno) {
            Parse pParse = this._pParse;
            if (((this._tracePrompt != null) 
                        && ((ruleno >= 0) 
                        && (ruleno < _ruleNames.Length)))) {
                Trace.WriteLine(String.Format("{0}Reduce [{1}].", this._tracePrompt, _ruleNames[ruleno]));
            }
            Minor gotoMinor = _zeroMinor;
switch (ruleno) {
/* Beginning here are the reduction cases.  A typical example
** follows:
**   case 0:
**  #line <lineno> <grammarfile>
**     { ... }           // User supplied code
**     break;
*/
    case 0: /* input ::= cmdlist */
    case 1: /* cmdlist ::= cmdlist ecmd */
    case 2: /* cmdlist ::= ecmd */
    case 3: /* ecmd ::= SEMI */
    case 4: /* ecmd ::= explain cmdx SEMI */
    case 10: /* trans_opt ::= */
    case 11: /* trans_opt ::= TRANSACTION */
    case 12: /* trans_opt ::= TRANSACTION nm */
    case 20: /* savepoint_opt ::= SAVEPOINT */
    case 21: /* savepoint_opt ::= */
    case 25: /* cmd ::= create_table create_table_args */
    case 34: /* columnlist ::= columnlist COMMA column */
    case 35: /* columnlist ::= column */
    case 44: /* type ::= */
    case 51: /* signed ::= plus_num */
    case 52: /* signed ::= minus_num */
    case 53: /* carglist ::= carglist carg */
    case 54: /* carglist ::= */
    case 55: /* carg ::= CONSTRAINT nm ccons */
    case 56: /* carg ::= ccons */
    case 62: /* ccons ::= NULL onconf */
    case 90: /* conslist ::= conslist COMMA tcons */
    case 91: /* conslist ::= conslist tcons */
    case 92: /* conslist ::= tcons */
    case 93: /* tcons ::= CONSTRAINT nm */
{


}
      break;
    case 5: /* explain ::= */
{
 sqlite3BeginParse(pParse, 0); 
}
      break;
    case 6: /* explain ::= EXPLAIN */
{
 sqlite3BeginParse(pParse, 1); 
}
      break;
    case 7: /* explain ::= EXPLAIN QUERY PLAN */
{
 sqlite3BeginParse(pParse, 2); 
}
      break;
    case 8: /* cmdx ::= cmd */
{
 sqlite3FinishCoding(pParse); 
}
      break;
    case 9: /* cmd ::= BEGIN transtype trans_opt */
{
 sqlite3BeginTransaction(pParse, _stack[_idx + -1].minor.yy0); 
}
      break;
    case 13: /* transtype ::= */
{
 gotoMinor.yy0 = TK.DEFERRED; 
}
      break;
    case 14: /* transtype ::= DEFERRED */
    case 15: /* transtype ::= IMMEDIATE */
    case 16: /* transtype ::= EXCLUSIVE */
    case 113: /* multiselect_op ::= UNION */
    case 115: /* multiselect_op ::= EXCEPT|INTERSECT */
{
 gotoMinor.yy0 = _stack[_idx + 0].major; 
}
      break;
    case 17: /* cmd ::= COMMIT trans_opt */
    case 18: /* cmd ::= END trans_opt */
{
 sqlite3CommitTransaction(pParse); 
}
      break;
    case 19: /* cmd ::= ROLLBACK trans_opt */
{
 sqlite3RollbackTransaction(pParse); 
}
      break;
    case 22: /* cmd ::= SAVEPOINT nm */
{
 sqlite3Savepoint(pParse, SAVEPOINT_BEGIN, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 23: /* cmd ::= RELEASE savepoint_opt nm */
{
 sqlite3Savepoint(pParse, SAVEPOINT_RELEASE, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 24: /* cmd ::= ROLLBACK trans_opt TO savepoint_opt nm */
{
 sqlite3Savepoint(pParse, SAVEPOINT_ROLLBACK, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 26: /* create_table ::= createkw temp TABLE ifnotexists nm dbnm */
{
 sqlite3StartTable(pParse, _stack[_idx + -1].minor.yy0, _stack[_idx + 0].minor.yy0, _stack[_idx + -4].minor.yy0, 0, 0, _stack[_idx + -2].minor.yy0); 
}
      break;
    case 27: /* createkw ::= CREATE */
{
 pParse.db.lookaside.bEnabled = 0; gotoMinor.yy0 = _stack[_idx + 0].minor.yy0; 
}
      break;
    case 28: /* ifnotexists ::= */
    case 31: /* temp ::= */
    case 70: /* autoinc ::= */
    case 83: /* defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt */
    case 85: /* init_deferred_pred_opt ::= */
    case 87: /* init_deferred_pred_opt ::= INITIALLY IMMEDIATE */
    case 98: /* defer_subclause_opt ::= */
    case 109: /* ifexists ::= */
    case 118: /* distinct ::= ALL */
    case 119: /* distinct ::= */
    case 157: /* groupby_opt ::= */
    case 159: /* having_opt ::= */
    case 220: /* between_op ::= BETWEEN */
    case 223: /* in_op ::= IN */
{
 gotoMinor.yy0 = 0; 
}
      break;
    case 29: /* ifnotexists ::= IF NOT EXISTS */
    case 30: /* temp ::= TEMP */
    case 71: /* autoinc ::= AUTOINCR */
    case 86: /* init_deferred_pred_opt ::= INITIALLY DEFERRED */
    case 108: /* ifexists ::= IF EXISTS */
    case 117: /* distinct ::= DISTINCT */
    case 221: /* between_op ::= NOT BETWEEN */
    case 224: /* in_op ::= NOT IN */
{
 gotoMinor.yy0 = 1; 
}
      break;
    case 32: /* create_table_args ::= LP columnlist conslist_opt RP */
{
 sqlite3EndTable(pParse, _stack[_idx + -1].minor.yy0, _stack[_idx + 0].minor.yy0, 0); 
}
      break;
    case 33: /* create_table_args ::= AS select */
{
 sqlite3EndTable(pParse, 0, 0, _stack[_idx + 0].minor.yy0); sqlite3SelectDelete(pParse.db, ref _stack[_idx + 0].minor.yy0); 
}
      break;
    case 36: /* column ::= columnid type carglist */
{
 gotoMinor.yy0.n = (int)(pParse.sLastToken.z.Length - _stack[_idx + -2].minor.yy0.z.Length) + pParse.sLastToken.z.Length; gotoMinor.yy0.z = _stack[_idx + -2].minor.yy0.z.Substring(0, gotoMinor.yy0.n); 
}
      break;
    case 37: /* columnid ::= nm */
{
 sqlite3AddColumn(pParse, _stack[_idx + 0].minor.yy0); gotoMinor.yy0 = _stack[_idx + 0].minor.yy0; 
}
      break;
    case 38: /* id ::= ID */
    case 39: /* id ::= INDEXED */
    case 40: /* ids ::= ID|STRING */
    case 41: /* nm ::= id */
    case 42: /* nm ::= STRING */
    case 43: /* nm ::= JOIN_KW */
    case 46: /* typetoken ::= typename */
    case 49: /* typename ::= ids */
    case 84: /* defer_subclause ::= DEFERRABLE init_deferred_pred_opt */
    case 99: /* defer_subclause_opt ::= defer_subclause */
    case 101: /* onconf ::= ON CONFLICT resolvetype */
    case 104: /* resolvetype ::= raisetype */
    case 111: /* select ::= oneselect */
    case 125: /* as ::= AS nm */
    case 126: /* as ::= ids */
    case 136: /* dbnm ::= DOT nm */
    case 145: /* indexed_opt ::= INDEXED BY nm */
    case 150: /* orderby_opt ::= ORDER BY sortlist */
    case 158: /* groupby_opt ::= GROUP BY nexprlist */
    case 174: /* insert_cmd ::= INSERT orconf */
    case 182: /* expr ::= term */
{
 gotoMinor.yy0 = _stack[_idx + 0].minor.yy0; 
}
      break;
    case 45: /* type ::= typetoken */
{
 sqlite3AddColumnType(pParse, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 47: /* typetoken ::= typename LP signed RP */
{
 gotoMinor.yy0.n = _stack[_idx + 0].minor.yy0.z.Length - _stack[_idx + -3].minor.yy0.z.Length + _stack[_idx + -3].minor.yy0.n; gotoMinor.yy0.z = _stack[_idx + -3].minor.yy0.z.Substring(0, gotoMinor.yy0.n); 
}
      break;
    case 48: /* typetoken ::= typename LP signed COMMA signed RP */
{
 gotoMinor.yy0.n = _stack[_idx + 0].minor.yy0.z.Length - _stack[_idx + -5].minor.yy0.z.Length + _stack[_idx + -5].minor.yy0.n; gotoMinor.yy0.z = _stack[_idx + -5].minor.yy0.z.Substring(0, gotoMinor.yy0.n); 
}
      break;
    case 50: /* typename ::= typename ids */
{
 gotoMinor.yy0.z = _stack[_idx + -1].minor.yy0.z; gotoMinor.yy0.n = _stack[_idx + 0].minor.yy0.n + _stack[_idx + 0].minor.yy0.z.Length - _stack[_idx + -1].minor.yy0.z.Length;  
}
      break;
    case 57: /* ccons ::= DEFAULT term */
    case 59: /* ccons ::= DEFAULT PLUS term */
{
 sqlite3AddDefaultValue(pParse, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 58: /* ccons ::= DEFAULT LP expr RP */
{
 sqlite3AddDefaultValue(pParse, _stack[_idx + -1].minor.yy0); 
}
      break;
    case 60: /* ccons ::= DEFAULT MINUS term */
{
 var v = new ExprSpan { pExpr = sqlite3PExpr(pParse, TK.UMINUS, _stack[_idx + 0].minor.yy0.pExpr, 0, 0), zStart = _stack[_idx + -1].minor.yy0.z, zEnd = _stack[_idx + 0].minor.yy0.zEnd }; sqlite3AddDefaultValue(pParse, v); 
}
      break;
    case 61: /* ccons ::= DEFAULT id */
{
 var v = new ExprSpan(); spanExpr(v, pParse, TK.STRING, _stack[_idx + 0].minor.yy0); sqlite3AddDefaultValue(pParse, v); 
}
      break;
    case 63: /* ccons ::= NOT NULL onconf */
{
 sqlite3AddNotNull(pParse, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 64: /* ccons ::= PRIMARY KEY sortorder onconf autoinc */
{
 sqlite3AddPrimaryKey(pParse, 0, _stack[_idx + -1].minor.yy0, _stack[_idx + 0].minor.yy0, _stack[_idx + -2].minor.yy0); 
}
      break;
    case 65: /* ccons ::= UNIQUE onconf */
{
 sqlite3CreateIndex(pParse, 0, 0, 0, 0, _stack[_idx + 0].minor.yy0, 0, 0, 0, 0);
}
      break;
    case 66: /* ccons ::= CHECK LP expr RP */
{
 sqlite3AddCheckConstraint(pParse, _stack[_idx + -1].minor.yy0.pExpr);
}
      break;
    case 67: /* ccons ::= REFERENCES nm idxlist_opt refargs */
{
 sqlite3CreateForeignKey(pParse, 0, _stack[_idx + -2].minor.yy0, _stack[_idx + -1].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 68: /* ccons ::= defer_subclause */
{
 sqlite3DeferForeignKey(pParse, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 69: /* ccons ::= COLLATE ids */
{
 sqlite3AddCollateType(pParse, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 72: /* refargs ::= */
{
 gotoMinor.yy0 = OE_None * 0x0101; 
}
      break;
    case 73: /* refargs ::= refargs refarg */
{
 gotoMinor.yy0 = (_stack[_idx + -1].minor.yy0 & ~_stack[_idx + 0].minor.yy0.mask) | _stack[_idx + 0].minor.yy0.value; 
}
      break;
    case 74: /* refarg ::= MATCH nm */
    case 75: /* refarg ::= ON INSERT refact */
{
 gotoMinor.yy0.value = 0;    gotoMinor.yy0.mask = 0x000000; 
}
      break;
    case 76: /* refarg ::= ON DELETE refact */
{
 gotoMinor.yy0.value = _stack[_idx + 0].minor.yy0;    gotoMinor.yy0.mask = 0x0000ff; 
}
      break;
    case 77: /* refarg ::= ON UPDATE refact */
{
 gotoMinor.yy0.value = _stack[_idx + 0].minor.yy0<<8; gotoMinor.yy0.mask = 0x00ff00; 
}
      break;
    case 78: /* refact ::= SET NULL */
{
 gotoMinor.yy0 = OE_SetNull; 
}
      break;
    case 79: /* refact ::= SET DEFAULT */
{
 gotoMinor.yy0 = OE_SetDflt; 
}
      break;
    case 80: /* refact ::= CASCADE */
{
 gotoMinor.yy0 = OE_Cascade; 
}
      break;
    case 81: /* refact ::= RESTRICT */
{
 gotoMinor.yy0 = OE_Restrict; 
}
      break;
    case 82: /* refact ::= NO ACTION */
{
 gotoMinor.yy0 = OE_None; 
}
      break;
    case 88: /* conslist_opt ::= */
{
 gotoMinor.yy0.n = 0; gotoMinor.yy0.z = null; 
}
      break;
    case 89: /* conslist_opt ::= COMMA conslist */
    case 120: /* sclp ::= selcollist COMMA */
    case 147: /* using_opt ::= USING LP inscollist RP */
    case 179: /* inscollist_opt ::= LP inscollist RP */
{
 gotoMinor.yy0 = _stack[_idx + -1].minor.yy0; 
}
      break;
    case 94: /* tcons ::= PRIMARY KEY LP idxlist autoinc RP onconf */
{
 sqlite3AddPrimaryKey(pParse, _stack[_idx + -3].minor.yy0, _stack[_idx + 0].minor.yy0, _stack[_idx + -2].minor.yy0, 0); 
}
      break;
    case 95: /* tcons ::= UNIQUE LP idxlist RP onconf */
{
 sqlite3CreateIndex(pParse, 0, 0, 0, _stack[_idx + -2].minor.yy0, _stack[_idx + 0].minor.yy0, 0, 0, 0, 0); 
}
      break;
    case 96: /* tcons ::= CHECK LP expr RP onconf */
{
 sqlite3AddCheckConstraint(pParse, _stack[_idx + -2].minor.yy0.pExpr); 
}
      break;
    case 97: /* tcons ::= FOREIGN KEY LP idxlist RP REFERENCES nm idxlist_opt refargs defer_subclause_opt */
{
 sqlite3CreateForeignKey(pParse, _stack[_idx + -6].minor.yy0, _stack[_idx + -3].minor.yy0, _stack[_idx + -2].minor.yy0, _stack[_idx + -1].minor.yy0); sqlite3DeferForeignKey(pParse, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 100: /* onconf ::= */
    case 102: /* orconf ::= */
{
 gotoMinor.yy0 = OE_Default; 
}
      break;
    case 103: /* orconf ::= OR resolvetype */
{
 gotoMinor.yy0 = (byte)_stack[_idx + 0].minor.yy0;
}
      break;
    case 105: /* resolvetype ::= IGNORE */
{
 gotoMinor.yy0 = OE_Ignore; 
}
      break;
    case 106: /* resolvetype ::= REPLACE */
    case 175: /* insert_cmd ::= REPLACE */
{
 gotoMinor.yy0 = OE_Replace; 
}
      break;
    case 107: /* cmd ::= DROP TABLE ifexists fullname */
{
 sqlite3DropTable(pParse, _stack[_idx + 0].minor.yy0, 0, _stack[_idx + -1].minor.yy0); 
}
      break;
    case 110: /* cmd ::= select */
{
 var dest = new SelectDest(SRT_Output, '\0', 0, 0, 0
}
      break;
    case 112: /* select ::= select multiselect_op oneselect */
{

	if (_stack[_idx + 0].minor.yy0 != null) { _stack[_idx + 0].minor.yy0->op = (TK)_stack[_idx + -1].minor.yy0; _stack[_idx + 0].minor.yy0->pPrior = _stack[_idx + -2].minor.yy0; }
	else { sqlite3SelectDelete(pParse.db, ref _stack[_idx + -2].minor.yy0); }
	gotoMinor.yy0 = _stack[_idx + 0].minor.yy0; 
}
      break;
    case 114: /* multiselect_op ::= UNION ALL */
{
 gotoMinor.yy0 = TK.ALL; 
}
      break;
    case 116: /* oneselect ::= SELECT selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt */
{
 gotoMinor.yy0 = sqlite3SelectNew(pParse, _stack[_idx + -6].minor.yy0, _stack[_idx + -5].minor.yy0, _stack[_idx + -4].minor.yy0, _stack[_idx + -3].minor.yy0, _stack[_idx + -2].minor.yy0, _stack[_idx + -1].minor.yy0, D, _stack[_idx + 0].minor.yy0.pLimit, _stack[_idx + 0].minor.yy0.pOffset); 
}
      break;
    case 121: /* sclp ::= */
    case 131: /* stl_prefix ::= */
    case 143: /* on_opt ::= */
    case 148: /* using_opt ::= */
    case 149: /* orderby_opt ::= */
    case 166: /* where_opt ::= */
    case 178: /* inscollist_opt ::= */
{
 gotoMinor.yy0 = null; 
}
      break;
    case 122: /* selcollist ::= sclp expr as */
{
 gotoMinor.yy0 = sqlite3ExprListAppend(pParse, _stack[_idx + -2].minor.yy0, _stack[_idx + -1].minor.yy0.pExpr); if (_stack[_idx + 0].minor.yy0.n > 0) sqlite3ExprListSetName(pParse, gotoMinor.yy0, _stack[_idx + 0].minor.yy0, 1); sqlite3ExprListSetSpan(pParse, gotoMinor.yy0, _stack[_idx + -1].minor.yy0); 
}
      break;
    case 123: /* selcollist ::= sclp STAR */
{
 var p = sqlite3Expr(pParse.db, TK.ALL, null); gotoMinor.yy0 = sqlite3ExprListAppend(pParse, _stack[_idx + -1].minor.yy0, p); 
}
      break;
    case 124: /* selcollist ::= sclp nm DOT STAR */
{
 var pRight = sqlite3PExpr(pParse, TK.ALL, 0, 0, _stack[_idx + 0].minor.yy0); var pLeft = sqlite3PExpr(pParse, TK.ID, 0, 0, _stack[_idx + -2].minor.yy0); var pDot = sqlite3PExpr(pParse, TK.DOT, pLeft, pRight, 0); gotoMinor.yy0 = sqlite3ExprListAppend(pParse, _stack[_idx + -3].minor.yy0, pDot); 
}
      break;
    case 127: /* as ::= */
{
 gotoMinor.yy0.n = 0; 
}
      break;
    case 128: /* from ::= */
{
 gotoMinor.yy0 = new SrcList(); 
}
      break;
    case 129: /* from ::= FROM seltablist */
{
 gotoMinor.yy0 = _stack[_idx + 0].minor.yy0; sqlite3SrcListShiftJoinType(gotoMinor.yy0); 
}
      break;
    case 130: /* stl_prefix ::= seltablist joinop */
{
 gotoMinor.yy0 = _stack[_idx + -1].minor.yy0; if (Sanity.ALWAYS(gotoMinor.yy0 != null && gotoMinor.yy0.nSrc > 0)) gotoMinor.yy0.a[gotoMinor.yy0.nSrc - 1].jointype = (byte)_stack[_idx + 0].minor.yy0; 
}
      break;
    case 132: /* seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt */
{
 gotoMinor.yy0 = sqlite3SrcListAppendFromTerm(pParse, _stack[_idx + -6].minor.yy0, _stack[_idx + -5].minor.yy0, _stack[_idx + -4].minor.yy0, _stack[_idx + -3].minor.yy0, 0, _stack[_idx + -1].minor.yy0, _stack[_idx + 0].minor.yy0); sqlite3SrcListIndexedBy(pParse, gotoMinor.yy0, _stack[_idx + -2].minor.yy0); 
}
      break;
    case 133: /* seltablist ::= stl_prefix LP select RP as on_opt using_opt */
{
 gotoMinor.yy0 = sqlite3SrcListAppendFromTerm(pParse, _stack[_idx + -6].minor.yy0, 0, 0, _stack[_idx + -2].minor.yy0, _stack[_idx + -4].minor.yy0, _stack[_idx + -1].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 134: /* seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */
{

	if (_stack[_idx + -6].minor.yy0 == null && _stack[_idx + -2].minor.yy0.n == 0 && _stack[_idx + -1].minor.yy0 == null && _stack[_idx + 0].minor.yy0 == null) { gotoMinor.yy0 = _stack[_idx + -4].minor.yy0; }
	else { sqlite3SrcListShiftJoinType(_stack[_idx + -4].minor.yy0); var pSubquery = sqlite3SelectNew(pParse, 0, _stack[_idx + -4].minor.yy0, 0, 0, 0, 0, 0, 0, 0); gotoMinor.yy0 = sqlite3SrcListAppendFromTerm(pParse, _stack[_idx + -6].minor.yy0, 0, 0, _stack[_idx + -2].minor.yy0, pSubquery, _stack[_idx + -1].minor.yy0, _stack[_idx + 0].minor.yy0); } 
}
      break;
    case 135: /* dbnm ::= */
    case 144: /* indexed_opt ::= */
{
 gotoMinor.yy0.z = null; gotoMinor.yy0.n = 0; 
}
      break;
    case 137: /* fullname ::= nm dbnm */
{
 gotoMinor.yy0 = sqlite3SrcListAppend(pParse.db, 0, _stack[_idx + -1].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 138: /* joinop ::= COMMA|JOIN */
{
 gotoMinor.yy0 = JT_INNER; 
}
      break;
    case 139: /* joinop ::= JOIN_KW JOIN */
{
 gotoMinor.yy0 = sqlite3JoinType(pParse, _stack[_idx + -1].minor.yy0, 0, 0); 
}
      break;
    case 140: /* joinop ::= JOIN_KW nm JOIN */
{
 gotoMinor.yy0 = sqlite3JoinType(pParse, _stack[_idx + -2].minor.yy0, _stack[_idx + -1].minor.yy0, 0); 
}
      break;
    case 141: /* joinop ::= JOIN_KW nm nm JOIN */
{
 gotoMinor.yy0 = sqlite3JoinType(pParse, _stack[_idx + -3].minor.yy0, _stack[_idx + -2].minor.yy0, _stack[_idx + -1].minor.yy0); 
}
      break;
    case 142: /* on_opt ::= ON expr */
    case 153: /* sortitem ::= expr */
    case 160: /* having_opt ::= HAVING expr */
    case 167: /* where_opt ::= WHERE expr */
{
 gotoMinor.yy0 = _stack[_idx + 0].minor.yy0.pExpr; 
}
      break;
    case 146: /* indexed_opt ::= NOT INDEXED */
{
 gotoMinor.yy0.z = null; gotoMinor.yy0.n = 1; 
}
      break;
    case 151: /* sortlist ::= sortlist COMMA sortitem sortorder */
{
 gotoMinor.yy0 = sqlite3ExprListAppend(pParse, _stack[_idx + -3].minor.yy0, _stack[_idx + -1].minor.yy0); if (gotoMinor.yy0 != null) gotoMinor.yy0->a[gotoMinor.yy0->nExpr-1].sortOrder = (u8)_stack[_idx + 0].minor.yy0; 
}
      break;
    case 152: /* sortlist ::= sortitem sortorder */
{
 gotoMinor.yy0 = sqlite3ExprListAppend(pParse, 0, _stack[_idx + -1].minor.yy0); if (gotoMinor.yy0 != null && Sanity.ALWAYS(gotoMinor.yy0.a != null)) gotoMinor.yy0.a[0].sortOrder = (byte)_stack[_idx + 0].minor.yy0; 
}
      break;
    case 154: /* sortorder ::= ASC */
    case 156: /* sortorder ::= */
{
 gotoMinor.yy0 = SQLITE_SO_ASC; 
}
      break;
    case 155: /* sortorder ::= DESC */
{
 gotoMinor.yy0 = SQLITE_SO_DESC; 
}
      break;
    case 161: /* limit_opt ::= */
{
 gotoMinor.yy0.pLimit = null; gotoMinor.yy0.pOffset = null; 
}
      break;
    case 162: /* limit_opt ::= LIMIT expr */
{
 gotoMinor.yy0.pLimit = _stack[_idx + 0].minor.yy0.pExpr; gotoMinor.yy0.pOffset = null; 
}
      break;
    case 163: /* limit_opt ::= LIMIT expr OFFSET expr */
{
 gotoMinor.yy0.pLimit = _stack[_idx + -2].minor.yy0.pExpr; gotoMinor.yy0.pOffset = _stack[_idx + 0].minor.yy0.pExpr; 
}
      break;
    case 164: /* limit_opt ::= LIMIT expr COMMA expr */
{
 gotoMinor.yy0.pOffset = _stack[_idx + -2].minor.yy0.pExpr; gotoMinor.yy0.pLimit = _stack[_idx + 0].minor.yy0.pExpr; 
}
      break;
    case 165: /* cmd ::= DELETE FROM fullname indexed_opt where_opt */
{
 sqlite3SrcListIndexedBy(pParse, _stack[_idx + -2].minor.yy0, _stack[_idx + -1].minor.yy0); sqlite3DeleteFrom(pParse, _stack[_idx + -2].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 168: /* cmd ::= UPDATE orconf fullname indexed_opt SET setlist where_opt */
{
 
	sqlite3SrcListIndexedBy(pParse, _stack[_idx + -4].minor.yy0, _stack[_idx + -3].minor.yy0); 
	sqlite3ExprListCheckLength(pParse, _stack[_idx + -1].minor.yy0, "set list"); 
	sqlite3Update(pParse, _stack[_idx + -4].minor.yy0, _stack[_idx + -1].minor.yy0, _stack[_idx + 0].minor.yy0, _stack[_idx + -5].minor.yy0); 
}
      break;
    case 169: /* setlist ::= setlist COMMA nm EQ expr */
{
 gotoMinor.yy0 = sqlite3ExprListAppend(pParse, _stack[_idx + -4].minor.yy0, _stack[_idx + 0].minor.yy0.pExpr); sqlite3ExprListSetName(pParse, gotoMinor.yy0, _stack[_idx + -2].minor.yy0, 1); 
}
      break;
    case 170: /* setlist ::= nm EQ expr */
{
 gotoMinor.yy0 = sqlite3ExprListAppend(pParse, 0, _stack[_idx + 0].minor.yy0.pExpr); sqlite3ExprListSetName(pParse, gotoMinor.yy0, _stack[_idx + -2].minor.yy0, 1); 
}
      break;
    case 171: /* cmd ::= insert_cmd INTO fullname inscollist_opt VALUES LP itemlist RP */
{
 sqlite3Insert(pParse, _stack[_idx + -5].minor.yy0, _stack[_idx + -1].minor.yy0, 0, _stack[_idx + -4].minor.yy0, _stack[_idx + -7].minor.yy0); 
}
      break;
    case 172: /* cmd ::= insert_cmd INTO fullname inscollist_opt select */
{
 sqlite3Insert(pParse, _stack[_idx + -2].minor.yy0, 0, _stack[_idx + 0].minor.yy0, _stack[_idx + -1].minor.yy0, _stack[_idx + -4].minor.yy0); 
}
      break;
    case 173: /* cmd ::= insert_cmd INTO fullname inscollist_opt DEFAULT VALUES */
{
 sqlite3Insert(pParse, _stack[_idx + -3].minor.yy0, 0, 0, _stack[_idx + -2].minor.yy0, _stack[_idx + -5].minor.yy0); 
}
      break;
    case 176: /* itemlist ::= itemlist COMMA expr */
{
 gotoMinor.yy0 = sqlite3ExprListAppend(pParse, _stack[_idx + -2].minor.yy0, _stack[_idx + 0].minor.yy0.pExpr); 
}
      break;
    case 177: /* itemlist ::= expr */
{
 gotoMinor.yy0 = sqlite3ExprListAppend(pParse, 0, _stack[_idx + 0].minor.yy0.pExpr); 
}
      break;
    case 180: /* inscollist ::= inscollist COMMA nm */
{
 gotoMinor.yy0 = sqlite3IdListAppend(pParse.db, _stack[_idx + -2].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 181: /* inscollist ::= nm */
{
 gotoMinor.yy0 = sqlite3IdListAppend(pParse.db, 0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 183: /* expr ::= LP expr RP */
{
 gotoMinor.yy0.pExpr = _stack[_idx + -1].minor.yy0.pExpr; spanSet(gotoMinor.yy0, _stack[_idx + -2].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 184: /* term ::= NULL */
    case 189: /* term ::= INTEGER|FLOAT|BLOB */
    case 190: /* term ::= STRING */
{
 spanExpr(gotoMinor.yy0, pParse, _stack[_idx + 0].major, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 185: /* expr ::= id */
    case 186: /* expr ::= JOIN_KW */
{
 spanExpr(gotoMinor.yy0, pParse, TK.ID, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 187: /* expr ::= nm DOT nm */
{

	var temp1 = sqlite3PExpr(pParse, TK.ID, 0, 0, _stack[_idx + -2].minor.yy0);
	var temp2 = sqlite3PExpr(pParse, TK.ID, 0, 0, _stack[_idx + 0].minor.yy0);
	gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.DOT, temp1, temp2, 0);
	spanSet(gotoMinor.yy0, _stack[_idx + -2].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 188: /* expr ::= nm DOT nm DOT nm */
{

	var temp1 = sqlite3PExpr(pParse, TK.ID, 0, 0, _stack[_idx + -4].minor.yy0);
	var temp2 = sqlite3PExpr(pParse, TK.ID, 0, 0, _stack[_idx + -2].minor.yy0);
	var temp3 = sqlite3PExpr(pParse, TK.ID, 0, 0, _stack[_idx + 0].minor.yy0);
	var temp4 = sqlite3PExpr(pParse, TK.DOT, temp2, temp3, 0);
	gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.DOT, temp1, temp4, 0);
	spanSet(gotoMinor.yy0, _stack[_idx + -4].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 191: /* expr ::= REGISTER */
{

	// When doing a nested parse, one can include terms in an expression that look like this:
	// #1 #2 ...  These terms refer to registers in the virtual machine.  #N is the N-th register. */
	if (pParse.nested == 0) { sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", _stack[_idx + 0].minor.yy0); gotoMinor.yy0.pExpr = null; }
	else { gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.REGISTER, 0, 0, _stack[_idx + 0].minor.yy0); if (gotoMinor.yy0.pExpr != null) sqlite3GetInt32(_stack[_idx + 0].minor.yy0.z, 1, ref gotoMinor.yy0.pExpr.iTable); }
	spanSet(gotoMinor.yy0, _stack[_idx + 0].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 192: /* expr ::= VARIABLE */
{
 spanExpr(gotoMinor.yy0, pParse, TK.VARIABLE, _stack[_idx + 0].minor.yy0); sqlite3ExprAssignVarNumber(pParse, gotoMinor.yy0.pExpr); spanSet(gotoMinor.yy0, _stack[_idx + 0].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 193: /* expr ::= expr COLLATE ids */
{
 gotoMinor.yy0.pExpr = sqlite3ExprSetCollByToken(pParse, _stack[_idx + -2].minor.yy0.pExpr, _stack[_idx + 0].minor.yy0); gotoMinor.yy0.zStart = _stack[_idx + -2].minor.yy0.zStart; gotoMinor.yy0.zEnd = _stack[_idx + 0].minor.yy0.z.Substring(_stack[_idx + 0].minor.yy0.n); 
}
      break;
    case 194: /* expr ::= CAST LP expr AS typetoken RP */
{
 gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.CAST, _stack[_idx + -3].minor.yy0.pExpr, 0, _stack[_idx + -1].minor.yy0); spanSet(gotoMinor.yy0, _stack[_idx + -5].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 195: /* expr ::= ID LP distinct exprlist RP */
{

	if (_stack[_idx + -1].minor.yy0 != null && _stack[_idx + -1].minor.yy0.nExpr > pParse.db.aLimit[SQLITE_LIMIT_FUNCTION_ARG]) sqlite3ErrorMsg(pParse, "too many arguments on function %T", _stack[_idx + -4].minor.yy0);
	gotoMinor.yy0.pExpr = sqlite3ExprFunction(pParse, _stack[_idx + -1].minor.yy0, _stack[_idx + -4].minor.yy0);
	spanSet(gotoMinor.yy0, _stack[_idx + -4].minor.yy0, _stack[_idx + 0].minor.yy0);
	if (_stack[_idx + -2].minor.yy0 != 0 && gotoMinor.yy0.pExpr != null) gotoMinor.yy0.pExpr->flags |= EP_Distinct; 
}
      break;
    case 196: /* expr ::= ID LP STAR RP */
{
 gotoMinor.yy0.pExpr = sqlite3ExprFunction(pParse, 0, _stack[_idx + -3].minor.yy0); spanSet(gotoMinor.yy0, _stack[_idx + -3].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 197: /* term ::= CTIME_KW */
{

	// The CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP values are treated as functions that return constants
	gotoMinor.yy0.pExpr != null) gotoMinor.yy0.pExpr.op = TK.CONST_FUNC;  
	spanSet(gotoMinor.yy0, _stack[_idx + 0].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 198: /* expr ::= expr AND expr */
    case 199: /* expr ::= expr OR expr */
    case 200: /* expr ::= expr LT|GT|GE|LE expr */
    case 201: /* expr ::= expr EQ|NE expr */
    case 202: /* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */
    case 203: /* expr ::= expr PLUS|MINUS expr */
    case 204: /* expr ::= expr STAR|SLASH|REM expr */
    case 205: /* expr ::= expr CONCAT expr */
{
 spanBinaryExpr(gotoMinor.yy0, pParse, _stack[_idx + -1].major, _stack[_idx + -2].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 206: /* likeop ::= LIKE_KW */
    case 208: /* likeop ::= MATCH */
{
 gotoMinor.yy0.eOperator = _stack[_idx + 0].minor.yy0; gotoMinor.yy0.not = false; 
}
      break;
    case 207: /* likeop ::= NOT LIKE_KW */
    case 209: /* likeop ::= NOT MATCH */
{
 gotoMinor.yy0.eOperator = _stack[_idx + 0].minor.yy0; gotoMinor.yy0.not = true; 
}
      break;
    case 210: /* expr ::= expr likeop expr */
{

	var pList = sqlite3ExprListAppend(pParse, 0, _stack[_idx + 0].minor.yy0.pExpr);
	pList = sqlite3ExprListAppend(pParse, pList, _stack[_idx + -2].minor.yy0.pExpr);
	gotoMinor.yy0.pExpr = sqlite3ExprFunction(pParse, pList, _stack[_idx + -1].minor.yy0.eOperator);
	if (_stack[_idx + -1].minor.yy0.not) gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK_NOT, gotoMinor.yy0.pExpr, 0, 0);
	gotoMinor.yy0.zStart = _stack[_idx + -2].minor.yy0.zStart; gotoMinor.yy0.zEnd = _stack[_idx + 0].minor.yy0.zEnd;
	if (gotoMinor.yy0.pExpr != null) gotoMinor.yy0.pExpr.flags |= EP_InfixFunc; 
}
      break;
    case 211: /* expr ::= expr likeop expr ESCAPE expr */
{

	var pList = sqlite3ExprListAppend(pParse, 0, _stack[_idx + -2].minor.yy0.pExpr);
	pList = sqlite3ExprListAppend(pParse, pList, _stack[_idx + -4].minor.yy0.pExpr);
	pList = sqlite3ExprListAppend(pParse, pList, _stack[_idx + 0].minor.yy0.pExpr);
	gotoMinor.yy0.pExpr = sqlite3ExprFunction(pParse, pList, _stack[_idx + -3].minor.yy0.eOperator);
	if (_stack[_idx + -3].minor.yy0.not) gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK_NOT, gotoMinor.yy0.pExpr, 0, 0);
	gotoMinor.yy0.zStart = _stack[_idx + -4].minor.yy0.zStart; gotoMinor.yy0.zEnd = _stack[_idx + 0].minor.yy0.zEnd;
	if (gotoMinor.yy0.pExpr != null) gotoMinor.yy0.pExpr.flags |= EP_InfixFunc; 
}
      break;
    case 212: /* expr ::= expr ISNULL|NOTNULL */
{
 spanUnaryPostfix(gotoMinor.yy0, pParse, _stack[_idx + 0].major, _stack[_idx + -1].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 213: /* expr ::= expr NOT NULL */
{
 spanUnaryPostfix(gotoMinor.yy0, pParse, TK.NOTNULL, _stack[_idx + -2].minor.yy0, _stack[_idx + 0].minor.yy0); 
}
      break;
    case 214: /* expr ::= expr IS expr */
{
 spanBinaryExpr(gotoMinor.yy0, pParse, TK.IS, _stack[_idx + -2].minor.yy0, _stack[_idx + 0].minor.yy0); binaryToUnaryIfNull(pParse, _stack[_idx + 0].minor.yy0.pExpr, gotoMinor.yy0.pExpr, TK.ISNULL); 
}
      break;
    case 215: /* expr ::= expr IS NOT expr */
{
 spanBinaryExpr(gotoMinor.yy0, pParse, TK.ISNOT, _stack[_idx + -3].minor.yy0, _stack[_idx + 0].minor.yy0); binaryToUnaryIfNull(pParse, _stack[_idx + 0].minor.yy0.pExpr, gotoMinor.yy0.pExpr, TK.NOTNULL); 
}
      break;
    case 216: /* expr ::= NOT expr */
    case 217: /* expr ::= BITNOT expr */
{
 spanUnaryPrefix(gotoMinor.yy0, pParse, _stack[_idx + -1].major, _stack[_idx + 0].minor.yy0, _stack[_idx + -1].minor.yy0); 
}
      break;
    case 218: /* expr ::= MINUS expr */
{
 spanUnaryPrefix(gotoMinor.yy0, pParse, TK.UMINUS, _stack[_idx + 0].minor.yy0, _stack[_idx + -1].minor.yy0); 
}
      break;
    case 219: /* expr ::= PLUS expr */
{
 spanUnaryPrefix(gotoMinor.yy0, pParse, TK.UPLUS, _stack[_idx + 0].minor.yy0, _stack[_idx + -1].minor.yy0); 
}
      break;
    case 222: /* expr ::= expr between_op expr AND expr */
{

	var pList = sqlite3ExprListAppend(pParse, 0, _stack[_idx + -2].minor.yy0.pExpr);
	pList = sqlite3ExprListAppend(pParse, pList, _stack[_idx + 0].minor.yy0.pExpr);
	gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.BETWEEN, _stack[_idx + -4].minor.yy0.pExpr, 0, 0);
	if (gotoMinor.yy0.pExpr != null) gotoMinor.yy0.pExpr.x.pList = pList;
	else sqlite3ExprListDelete(pParse.db, pList);
	if (_stack[_idx + -3].minor.yy0 != 0) gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.NOT, gotoMinor.yy0.pExpr, 0, 0);
	gotoMinor.yy0.zStart = _stack[_idx + -4].minor.yy0.zStart; gotoMinor.yy0.zEnd = _stack[_idx + 0].minor.yy0.zEnd;

}
      break;
    case 225: /* expr ::= expr in_op LP exprlist RP */
{

	if (_stack[_idx + -1].minor.yy0 == null) {
		// Expressions of the form
		//      expr1 IN ()
		//      expr1 NOT IN ()
		// simplify to constants 0 (false) and 1 (true), respectively,  regardless of the value of expr1.
		gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.INTEGER, 0, 0, sqlite3IntTokens[_stack[_idx + -3].minor.yy0]);
		sqlite3ExprDelete(pParse.db, _stack[_idx + -4].minor.yy0.pExpr);
	} else {
		gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.IN, _stack[_idx + -4].minor.yy0.pExpr, 0, 0);
		if (gotoMinor.yy0.pExpr != null) { gotoMinor.yy0.pExpr.x.pList = _stack[_idx + -1].minor.yy0; sqlite3ExprSetHeight(pParse, gotoMinor.yy0.pExpr); }
		else sqlite3ExprListDelete(pParse.db, ref _stack[_idx + -1].minor.yy0);
		if (_stack[_idx + -3].minor.yy0 != 0) gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.NOT, gotoMinor.yy0.pExpr, 0, 0);
    }
    gotoMinor.yy0.zStart = _stack[_idx + -4].minor.yy0.zStart; gotoMinor.yy0.zEnd = _stack[_idx + 0].minor.yy0.z.Substring(_stack[_idx + 0].minor.yy0.n); 
}
      break;
    case 226: /* expr ::= LP select RP */
{

	gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.SELECT, 0, 0, 0);
    if (gotoMinor.yy0.pExpr != null) { gotoMinor.yy0.pExpr.x.pSelect = _stack[_idx + -1].minor.yy0; Expr.ExprSetProperty(gotoMinor.yy0.pExpr, EP_xIsSelect); sqlite3ExprSetHeight(pParse, gotoMinor.yy0.pExpr); }
	else sqlite3SelectDelete(pParse.db, ref _stack[_idx + -1].minor.yy0);
    gotoMinor.yy0.zStart = _stack[_idx + -2].minor.yy0.z; gotoMinor.yy0.zEnd = _stack[_idx + 0].minor.yy0.z.Substring(_stack[_idx + 0].minor.yy0.n); 
}
      break;
    case 227: /* expr ::= expr in_op LP select RP */
{

	gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.IN, _stack[_idx + -4].minor.yy0.pExpr, 0, 0);
    if (gotoMinor.yy0.pExpr != null) { gotoMinor.yy0.pExpr.x.pSelect = _stack[_idx + -1].minor.yy0; Expr.ExprSetProperty(gotoMinor.yy0.pExpr, EP_xIsSelect); sqlite3ExprSetHeight(pParse, gotoMinor.yy0.pExpr);
    else sqlite3SelectDelete(pParse.db, ref _stack[_idx + -1].minor.yy0);
    if (_stack[_idx + -3].minor.yy0 != 0) gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.NOT, gotoMinor.yy0.pExpr, 0, 0);
    gotoMinor.yy0.zStart = _stack[_idx + -4].minor.yy0.zStart; gotoMinor.yy0.zEnd = _stack[_idx + 0].minor.yy0.z.Substring(_stack[_idx + 0].minor.yy0.n);
}
expr(gotoMinor.yy0) ::= expr(_stack[_idx + -4].minor.yy0) in_op(_stack[_idx + -3].minor.yy0) nm(_stack[_idx + -1].minor.yy0) dbnm(Z). [IN] {
	var pSrc = sqlite3SrcListAppend(pParse.db, 0, _stack[_idx + -1].minor.yy0, Z);
    gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.IN, _stack[_idx + -4].minor.yy0.pExpr, 0, 0);
    if (gotoMinor.yy0.pExpr != null) { gotoMinor.yy0.pExpr.x.pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0,0); Expr.ExprSetProperty(gotoMinor.yy0.pExpr, EP_xIsSelect); sqlite3ExprSetHeight(pParse, gotoMinor.yy0.pExpr); }
	else sqlite3SrcListDelete(pParse.db, ref pSrc);
    if (_stack[_idx + -3].minor.yy0 != 0) gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.NOT, gotoMinor.yy0.pExpr, 0, 0);
    gotoMinor.yy0.zStart = _stack[_idx + -4].minor.yy0.zStart; gotoMinor.yy0.zEnd = (Z.z != null ? Z.z.Substring(Z.n) : _stack[_idx + -1].minor.yy0.z.Substring(_stack[_idx + -1].minor.yy0.n));
}
expr(gotoMinor.yy0) ::= EXISTS(B) LP select(_stack[_idx + -1].minor.yy0) RP(_stack[_idx + 0].minor.yy0). {
    var p = gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.EXISTS, 0, 0, 0);
    if (p != null) { p.x.pSelect = _stack[_idx + -1].minor.yy0; Expr.ExprSetProperty(p, EP_xIsSelect); sqlite3ExprSetHeight(pParse, p); }
	else sqlite3SelectDelete(pParse.db, ref _stack[_idx + -1].minor.yy0);
    gotoMinor.yy0.zStart = B.z; gotoMinor.yy0.zEnd = _stack[_idx + 0].minor.yy0.z.Substring(_stack[_idx + 0].minor.yy0.n);
}
// CASE expressions
expr(gotoMinor.yy0) ::= CASE(C) case_operand(_stack[_idx + -4].minor.yy0) case_exprlist(_stack[_idx + -1].minor.yy0) case_else(Z) END(_stack[_idx + 0].minor.yy0). {
	gotoMinor.yy0.pExpr = sqlite3PExpr(pParse, TK.CASE, _stack[_idx + -4].minor.yy0, Z, 0);
	if (gotoMinor.yy0.pExpr != null) { gotoMinor.yy0.pExpr.x.pList = _stack[_idx + -1].minor.yy0; sqlite3ExprSetHeight(pParse, gotoMinor.yy0.pExpr); }
	else sqlite3ExprListDelete(pParse.db, _stack[_idx + -1].minor.yy0);
	gotoMinor.yy0.zStart = C.z; gotoMinor.yy0.zEnd = _stack[_idx + 0].minor.yy0.z.Substring(_stack[_idx + 0].minor.yy0.n);
}
%type case_exprlist {ExprList}
%destructor case_exprlist { sqlite3ExprListDelete(pParse.db, $$); }
case_exprlist(gotoMinor.yy0) ::= case_exprlist(_stack[_idx + -4].minor.yy0) WHEN expr(_stack[_idx + -1].minor.yy0) THEN expr(Z).	{ gotoMinor.yy0 = sqlite3ExprListAppend(pParse, _stack[_idx + -4].minor.yy0, _stack[_idx + -1].minor.yy0.pExpr); gotoMinor.yy0 = sqlite3ExprListAppend(pParse, gotoMinor.yy0, Z.pExpr); }
case_exprlist(gotoMinor.yy0) ::= WHEN expr(_stack[_idx + -1].minor.yy0) THEN expr(Z).						{ gotoMinor.yy0 = sqlite3ExprListAppend(pParse, 0, _stack[_idx + -1].minor.yy0.pExpr); gotoMinor.yy0 = sqlite3ExprListAppend(pParse, gotoMinor.yy0, Z.pExpr); }
%type case_else {Expr}
%destructor case_else { sqlite3ExprDelete(pParse.db, $$); }
case_else(gotoMinor.yy0) ::= ELSE expr(_stack[_idx + -4].minor.yy0).	{ gotoMinor.yy0 = _stack[_idx + -4].minor.yy0.pExpr; }
case_else(gotoMinor.yy0) ::= .				{ gotoMinor.yy0 = 0; }
%type case_operand {Expr}
%destructor case_operand { sqlite3ExprDelete(pParse.db, $$); }
case_operand(gotoMinor.yy0) ::= expr(_stack[_idx + -4].minor.yy0).    { gotoMinor.yy0 = _stack[_idx + -4].minor.yy0.pExpr; } 
case_operand(gotoMinor.yy0) ::= .           { gotoMinor.yy0 = 0; } 
//
%type exprlist {ExprList}
%destructor exprlist { sqlite3ExprListDelete(pParse.db, $$); }
%type nexprlist {ExprList}
%destructor nexprlist { sqlite3ExprListDelete(pParse.db, $$); }
exprlist(gotoMinor.yy0) ::= nexprlist(_stack[_idx + -4].minor.yy0).					{ gotoMinor.yy0 = _stack[_idx + -4].minor.yy0; }
exprlist(gotoMinor.yy0) ::= .								{ gotoMinor.yy0 = 0; }
nexprlist(gotoMinor.yy0) ::= nexprlist(_stack[_idx + -4].minor.yy0) COMMA expr(_stack[_idx + -1].minor.yy0).	{ gotoMinor.yy0 = sqlite3ExprListAppend(pParse, _stack[_idx + -4].minor.yy0, _stack[_idx + -1].minor.yy0.pExpr); }
nexprlist(gotoMinor.yy0) ::= expr(_stack[_idx + -1].minor.yy0).						{ gotoMinor.yy0 = sqlite3ExprListAppend(pParse, 0, _stack[_idx + -1].minor.yy0.pExpr); }


///////////////////////////// The PRAGMA command /////////////////////////////
//
cmd ::= PRAGMA nm(_stack[_idx + -4].minor.yy0) dbnm(Z).					{ sqlite3Pragma(pParse, _stack[_idx + -4].minor.yy0, Z, 0, 0); }
cmd ::= PRAGMA nm(_stack[_idx + -4].minor.yy0) dbnm(Z) EQ nmnum(_stack[_idx + -1].minor.yy0).		{ sqlite3Pragma(pParse, _stack[_idx + -4].minor.yy0, Z, _stack[_idx + -1].minor.yy0, 0); }
cmd ::= PRAGMA nm(_stack[_idx + -4].minor.yy0) dbnm(Z) LP nmnum(_stack[_idx + -1].minor.yy0) RP.	{ sqlite3Pragma(pParse, _stack[_idx + -4].minor.yy0, Z, _stack[_idx + -1].minor.yy0, 0); }
cmd ::= PRAGMA nm(_stack[_idx + -4].minor.yy0) dbnm(Z) EQ minus_num(_stack[_idx + -1].minor.yy0).	{ sqlite3Pragma(pParse, _stack[_idx + -4].minor.yy0, Z, _stack[_idx + -1].minor.yy0, 1); }
cmd ::= PRAGMA nm(_stack[_idx + -4].minor.yy0) dbnm(Z) LP minus_num(_stack[_idx + -1].minor.yy0) RP.{ sqlite3Pragma(pParse, _stack[_idx + -4].minor.yy0, Z, _stack[_idx + -1].minor.yy0, 1); }
nmnum(gotoMinor.yy0) ::= plus_num(_stack[_idx + -4].minor.yy0).			{ gotoMinor.yy0 = _stack[_idx + -4].minor.yy0; }
nmnum(gotoMinor.yy0) ::= nm(_stack[_idx + -4].minor.yy0).					{ gotoMinor.yy0 = _stack[_idx + -4].minor.yy0; }
nmnum(gotoMinor.yy0) ::= ON(_stack[_idx + -4].minor.yy0).					{ gotoMinor.yy0 = _stack[_idx + -4].minor.yy0; }
nmnum(gotoMinor.yy0) ::= DELETE(_stack[_idx + -4].minor.yy0).				{ gotoMinor.yy0 = _stack[_idx + -4].minor.yy0; }
nmnum(gotoMinor.yy0) ::= DEFAULT(_stack[_idx + -4].minor.yy0).			{ gotoMinor.yy0 = _stack[_idx + -4].minor.yy0; }
plus_num(gotoMinor.yy0) ::= plus_opt number(_stack[_idx + -4].minor.yy0).	{ gotoMinor.yy0 = _stack[_idx + -4].minor.yy0; }
minus_num(gotoMinor.yy0) ::= MINUS number(_stack[_idx + -4].minor.yy0).	{ gotoMinor.yy0 = _stack[_idx + -4].minor.yy0; }
number(gotoMinor.yy0) ::= INTEGER|FLOAT(_stack[_idx + -4].minor.yy0).		{ gotoMinor.yy0 = _stack[_idx + -4].minor.yy0; }
plus_opt ::= PLUS.
plus_opt ::= .


//////////////////////// ALTER TABLE table ... ////////////////////////////////
//
cmd ::= ALTER TABLE fullname(_stack[_idx + -4].minor.yy0) RENAME TO nm(Z).					{ sqlite3AlterRenameTable(pParse, _stack[_idx + -4].minor.yy0, Z); }
cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column(_stack[_idx + -1].minor.yy0). { sqlite3AlterFinishAddColumn(pParse, _stack[_idx + -1].minor.yy0); }
add_column_fullname ::= fullname(_stack[_idx + -4].minor.yy0). { pParse.db.lookaside.bEnabled = 0; sqlite3AlterBeginAddColumn(pParse, _stack[_idx + -4].minor.yy0); }
kwcolumn_opt ::= .
kwcolumn_opt ::= COLUMNKW.
}
      break;
      default:
      break;
}
            int @goto = _ruleInfos[ruleno].LHSymbol;
            int size = _ruleInfos[ruleno].RHSymbols;
            this._idx = (this._idx - size);
            int action = this.FindReduceAction(this._stack[this._idx].stateno, ((byte)(@goto)));
            if ((action < STATES)) {
                this.Shift(action, @goto, gotoMinor);
                return;
            }
            Debug.Assert((action == ACCEPT_ACTION));
            this.Accept();
        }
        #endregion
        #region Syntax: StackOverflow
        /// <summary>
        /// The following routine is called if the stack overflows.
        /// </summary>
        private void StackOverflow(Minor minor) {
            Parse pParse = this._pParse;
            this._idx = (this._idx + 1);
            if ((this._tracePrompt != null)) {
                Trace.WriteLine(String.Format("{0}Stack Overflow!", this._tracePrompt));
            }
            for (
            ; (this._idx >= 0); 
            ) {
                this.PopParserStack();
            }
            // Here code is inserted which will execute if the parser stack every overflows
#line 10 "C:\\_APPLICATION\\FEASERVER\\ENGINE_\\FeaServer.Engine\\Query\\Parser.y"

	sqlite3ErrorMsg(parse, "parser stack overflow");
	parse.parseError = 1;

            this._pParse = pParse;
        }
        #endregion
        #region Syntax: Parse Failed
        /// <summary>
        /// The following code executes when the parse fails
        /// </summary>
        // Here code is inserted which will be executed whenever the parser fails
        private void ParseFailed() {
            Parse pParse = this._pParse;
            if ((this._tracePrompt != null)) {
                Trace.WriteLine(String.Format("{0}Fail!", this._tracePrompt));
            }
            for (
            ; (this._idx >= 0); 
            ) {
                this.PopParserStack();
            }
            this._pParse = pParse;
        }
        #endregion
        #region Syntax: Syntax Error
        /// <summary>
        /// The following code executes when a syntax error first occurs.
        /// </summary>
        private void SyntaxError(int major, Minor minor) {
            Parse pParse = this._pParse;
#line 5 "C:\\_APPLICATION\\FEASERVER\\ENGINE_\\FeaServer.Engine\\Query\\Parser.y"

	Debug.Assert(minor.yy0.z.Length > 0);  /* The tokenizer always gives us a token */
	sqlite3ErrorMsg(parse, "near \"%T\": syntax error", minor.yy0);
	parse.parseError = 1;

            this._pParse = pParse;
        }
        #endregion
        #region Syntax: Accept
        /// <summary>
        /// The following is executed when the parser accepts
        /// </summary>
        // Here code is inserted which will be executed whenever the parser accepts
        private void Accept() {
            Parse pParse = this._pParse;
            if ((this._tracePrompt != null)) {
                Trace.WriteLine(String.Format("{0}Accept!", this._tracePrompt));
            }
            for (
            ; (this._idx >= 0); 
            ) {
                this.PopParserStack();
            }
            this._pParse = pParse;
        }
        #endregion
        #region Types: Tokens
        /// <summary>
        /// These constants (all generated automatically by the parser generator) specify the various kinds of tokens (terminals) that the parser understands.
        /// Each symbol here is a terminal symbol in the grammar.
        /// </summary>
        public enum TK {
            SEMI = 1,
            EXPLAIN = 2,
            QUERY = 3,
            PLAN = 4,
            BEGIN = 5,
            TRANSACTION = 6,
            DEFERRED = 7,
            IMMEDIATE = 8,
            EXCLUSIVE = 9,
            COMMIT = 10,
            END = 11,
            ROLLBACK = 12,
            SAVEPOINT = 13,
            RELEASE = 14,
            TO = 15,
            TABLE = 16,
            CREATE = 17,
            IF = 18,
            NOT = 19,
            EXISTS = 20,
            TEMP = 21,
            LP = 22,
            RP = 23,
            AS = 24,
            COMMA = 25,
            ID = 26,
            INDEXED = 27,
            ABORT = 28,
            ACTION = 29,
            AFTER = 30,
            ANALYZE = 31,
            ASC = 32,
            ATTACH = 33,
            BEFORE = 34,
            BY = 35,
            CASCADE = 36,
            CAST = 37,
            COLUMNKW = 38,
            CONFLICT = 39,
            DATABASE = 40,
            DESC = 41,
            DETACH = 42,
            EACH = 43,
            FAIL = 44,
            FOR = 45,
            IGNORE = 46,
            INITIALLY = 47,
            INSTEAD = 48,
            LIKE_KW = 49,
            MATCH = 50,
            NO = 51,
            KEY = 52,
            OF = 53,
            OFFSET = 54,
            PRAGMA = 55,
            RAISE = 56,
            REPLACE = 57,
            RESTRICT = 58,
            ROW = 59,
            TRIGGER = 60,
            VACUUM = 61,
            VIEW = 62,
            VIRTUAL = 63,
            EXCEPT = 64,
            INTERSECT = 65,
            UNION = 66,
            REINDEX = 67,
            RENAME = 68,
            CTIME_KW = 69,
            ANY = 70,
            OR = 71,
            AND = 72,
            IS = 73,
            BETWEEN = 74,
            IN = 75,
            ISNULL = 76,
            NOTNULL = 77,
            NE = 78,
            EQ = 79,
            GT = 80,
            LE = 81,
            LT = 82,
            GE = 83,
            ESCAPE = 84,
            BITAND = 85,
            BITOR = 86,
            LSHIFT = 87,
            RSHIFT = 88,
            PLUS = 89,
            MINUS = 90,
            STAR = 91,
            SLASH = 92,
            REM = 93,
            CONCAT = 94,
            COLLATE = 95,
            BITNOT = 96,
            STRING = 97,
            JOIN_KW = 98,
            CONSTRAINT = 99,
            DEFAULT = 100,
            NULL = 101,
            PRIMARY = 102,
            UNIQUE = 103,
            CHECK = 104,
            REFERENCES = 105,
            AUTOINCR = 106,
            ON = 107,
            INSERT = 108,
            DELETE = 109,
            UPDATE = 110,
            SET = 111,
            DEFERRABLE = 112,
            FOREIGN = 113,
            DROP = 114,
            ALL = 115,
            SELECT = 116,
            DISTINCT = 117,
            DOT = 118,
            FROM = 119,
            JOIN = 120,
            USING = 121,
            ORDER = 122,
            GROUP = 123,
            HAVING = 124,
            LIMIT = 125,
            WHERE = 126,
            INTO = 127,
            VALUES = 128,
            INTEGER = 129,
            FLOAT = 130,
            BLOB = 131,
            REGISTER = 132,
            VARIABLE = 133,
        }
        #endregion
        #region Types: Minor
        [StructLayout(LayoutKind.Explicit)]
        public struct Minor {
            [FieldOffset(0)]
            public int yyinit;
            [FieldOffset(0)]
            public Token yy0;
        }
        #endregion
        #region Types: StackEntry
        /// <summary>
        /// The following structure represents a single element of the parser's stack.  Information stored includes:
        ///  +  The state number for the parser at this level of the stack.
        ///  +  The value of the token stored at this level of the stack. (In other words, the "major" token.)
        ///  +  The semantic value stored at this level of the stack.  This is the information used by the action routines in the grammar. It is sometimes called the "minor" token.
        /// </summary>
        public struct StackEntry {
            // The state-number
            public byte stateno;
            // The major token value.  This is the code number for the token at this stack level
            public byte major;
            // The user-supplied minor token value.  This is the value of the token
            public Minor minor;
        }
        #endregion
        #region Types: RuleInfo
        public struct RuleInfo {
            public byte LHSymbol;
            public byte RHSymbols;
            public RuleInfo(byte lhSymbol, byte rhSymbols) {
                this.LHSymbol = lhSymbol;
                this.RHSymbols = rhSymbols;
            }
        }
        #endregion
    }
}
